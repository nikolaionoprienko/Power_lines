import numpy as np


# a = np.array([1, 2, 3, 4])  # Создание массива
# type_a = a.dtype  # Тип элементов массива
#
# print(a, type_a)
#
# a_0 = a[0]  # Вызов первого элемента
# print(a_0)
#
# a[0] = 123  # Измененине первого элемента
# print(a[0])
# a[0] = 1
#
# array_a = a[[1, 2, 3, 0, 1, 2, 3, 0]]  # Указывая массив индексов для массива, мы создаём массив из элементов, индексы которого мы прописали
# print(array_a, type(array_a))  # [  2   3   4 123   2   3   4 123] <class 'numpy.ndarray'>
#
# array_a = a[[True, False, True, False]]  # Будут выводится те элементы, на местах который True
# print(array_a, a)
#
# b = a.reshape(2, 2)  # Превращает одномерный массив а в массив 2*2 (матрицу строку в квадратную матрицу второго порядка)
# print(b)
# print(b[0][1], b[0, 1])  # Два способа вызвать элемент из первой строки и второго столбца


# Урок 1:

# a = np.array([1, 2, 3, 4], "float64")  # Создание одномерного массива сразу с типом данных вещественых чисел
# print(a)
#
# complex_num = np.complex64(10)  # Преобразования целого числа в комплексное
# print(complex_num)
#
# # a = np.array([1, 2, 5000, 1000], dtype='int8')  # Выдаст ошибку переполнения OverflowError
#
# a = np.complex64(a)  # приведение элементов массива  а к комплексным числам
# print(a)
#
# # b = np.int32(a)  # выдаст предупреждение о возможной потери информации (потеря мнимой части)
# # print(b)
#
# a = np.array((1, 2, 3, 4))  # Преобразование картежа в массив
# print(a)
#
# a = np.array("1234")
# print(a)  # преобразовываться в массив будут списки и картежи, все остальные типы данных будут восприниматься как отдельный элемент.
#
# a = np.array([
#     [1, 2, 3],
#     [4, 5, 6],
#     [7, 8, 9]
#     ])  # Создание многомерного массива (матрица 3*3) (Должна быть именно матрица (Прямоугольная таблица))
# print(a, "\n")
#
# a = np.array([
#     [
#         [1, 2, 3],
#         [4, 5, 6]
#     ],
#
#     [
#         [7, 8, 9],
#         [10, 11, 12]
#     ]
# ])  # Создание трёхмерной матрицы
# print(a, "\n")
#
# print(a[0])  # Двумерный срех трёхмерной матрицы (обращение к первой матрице)
# print()
# print(a[1, 0])  # Обращение к самой первой строке второй матрицы
# print()
# print(a[1, 1, 0])  # Обращение к элементу второй матрицы второй строки первого столбца

# Урок 2 Автозаполнения

# a = np.array([0]*10)  # список с 10-ю нулями
# print(a)
#
# a = np.array([x**2 for x in np.arange(10)])  # Генерация списка
# print(a)
#
# a = np.empty(10, dtype='int16')  # Создание строки с 10-ю произвольными числами
# print(a)
#
# a = np.empty((3, 2), dtype='int16')  # двумерный массив с произвольными числами
# print(a)
#
# a = np.eye(4)  # Создание единичной матрицы 4-го порядка
# print(a, "\n")
#
# a = np.eye(2, 4)  # Создание матрицы с единицами по главной диагонали, остальные нули
# print(a, "\n")
#
# a = np.zeros((2, 3, 3))  # Тензор со всеми нулями
# print(a, "\n")
#
# a = np.ones((2, 3, 3))  # Массив из всех единиц
# print(a, "\n")
#
# a = np.full((3, 5), -123)  # Массив полностью состоящий из -123
# print(a, "\n")
#
# a = np.matrix('1 2 3 4')  # Создаёт матрицу 1*4
# print(a, "\n")
#
# a = np.matrix('1, 2, 3; 4, 5, 6; 7, 8, 9; 10, 11, 12')  # Матрица 4*3
# print(a, "\n")
#
# a = np.matrix('1 2 3; 4 5 6; 7 8 9; 10 11 12')  # Матрица 4*3 (Можно без запятых и с ними)
# print(a, "\n")
#
# a = np.matrix([
#     [1, 2, 3],
#     [4, 5, 6]
# ])
# print(a, "\n")
#
# a = np.diag([1, 2, 3, 4])   # Матрица у которой на диагонали будут указанные значения, а остальные нули
# print(a, "\n")
#
# a = np.diag([
#     [1, 2, 3],
#     [4, 5, 6],
#     [7, 8, 9],
#     [10, 11, 12]
# ])  # создаёт матрицу строку с элементами из главной диагонали матрицы
# print(a, "\n")
#
# a = np.diagflat([
#     [1, 2, 3],
#     [4, 5, 6],
#     [7, 8, 9],
# ])  # В случае если хотим сделать диагональную матрицу из элементов матрицы, а не строки
# print(a, "\n")
#
# a = np.tri(4)  # Cоздание нижне-треугольной квадратной матрицы
# print(a, "\n")
#
# a = np.tri(5, 6)  # Создание нижне-треугольной прямоугольной матрицы
# print(a, "\n")
#
#
# a = np.array([
#     [1, 2, 3],
#     [4, 5, 6],
#     [7, 8, 9]
# ])
# print(a, "\n")
#
# a = np.tril(a)  # Превращает матрицу в нижнетреугольную
# print(a, "\n")
#
#
# a = np.array([
#     [1, 2, 3],
#     [4, 5, 6],
#     [7, 8, 9]
# ])
# print(a, "\n")
# a = np.triu(a)
# print(a, "\n")  # Превращает матрицу в верхнетреугольную
#
# a = np.vander([1, 2, 3])  # Cоздание матрицы вандермонда
# print(a, "\n")

# a = np.arange(5)
# print(a)  # [0 1 2 3 4]
#
# a = np.arange(2, 5)
# print(a)  # [2 3 4]

# a = np.arange(2, 5, 0.5)
# print(a)  # [2.  2.5 3.  3.5 4.  4.5]  В отличии от обычного range, где шаг может быть только целый
#
# a = np.arange(0, np.pi, 0.1)
# cos = np.cos(a)
# print(a, cos)
#
# cos = np.cos(np.arange(0, 2*np.pi, 0.1))
# print(cos)


# lin = np.linspace(0, 10, 100)
# print(lin, "\n")  # равномерно поделённый на 100 частей отрезок от 0 до 10
#
# log = np.logspace(0, 3, 4)
# print(log)  # равномерное деление на 10 частей чисел от 0 до 10 в логарифмической шкале [   1.   10.  100. 1000.]
#             # 3 здесь это степень 10-ки
#
# geom = np.geomspace(2, 64, 6)
# print(geom)  # [ 2.  4.  8. 16. 32. 64.]

# a = np.array([
#     [1, 2],
#     [3, 4]
# ])
#
# b = np.copy(a)
# print(a, "\n", b)
#
# b[0, 0] = -1
# print(a, "\n", b)

# def getrange(x, y):
#     return 100*x + y
#
#
# a = np.fromfunction(getrange, (2, 2))  # x и y будут индексами
# print(a)  # [[  0.   1.] [100. 101.]]
#
# a = np.fromfunction(lambda x, y: x*100 + y, (2, 2))
# print(a)

# a = np.fromiter("Преобразуй меня полностью", dtype='<U1')  # Создаёт из списка массив
# print(a)
#
#
# def getrange(n):
#     for i in range(n):
#         yield i  # При повторном вызове такой функции выполнение продолжается с оператора yield, на котором её работа была прервана.
#
#
# a = np.fromiter(getrange(4), dtype='int8')
# print(a)

# a = np.fromstring('1 2 3', dtype='int16', sep=' ')  # из строки делает массив (sep - разделитель)
# print(a)
#
# a = np.fromstring('1, 2, 3', dtype='int16', sep=',')
# print(a)

# Урок 4: свойства и представления массивов

# a = np.arange(0.1, 1, 0.1)
# print(a)
# print(a.dtype)
#
# a.dtype = np.int8()  # Меняем тип элементов
# print(a)             # (Раньше каждое число кодировалось 64 битами, теперь будет 8-мью, поэтому каждый элемент разобётся
#                      # на 8 частей и добавится в список, поэтому количество элементов возрастёт в 8 раз) (Нет потери данных)
#
# print(a.size)  # Узнаём количество элементов
#
# a.dtype = np.float64  # так как данные не теряются вернёмся к исходному списку
# print(a)
#
# print(a.itemsize)  # Узнаём сколько весит элемент в байтах
# print(a.size * a.itemsize)  # Узнаём сколько весит весь массив

# b = np.ones((3, 4, 5))
# print(b)
# print(b.ndim)  # Узнаём размерность массива
# print(b.shape)  # Узнаём количество элементов по каждой из осей
# b.shape = 60  # Меняем размерность массива вводя количество элементов в каждой оси, причём общее количество элементов должно быть неизменно
# print(b)
# b.shape = (12, 5)
# print(b)
#
# # Нужно понимать, что меняется только представления данных, а данные не меняются:
#
# c = b.reshape(60)
# print(b, "\n", c)  # Ccылаемся на разные представления одних и тех же данных
#
# b[0, 0] = 100
# print(b, '\n', c)  # Хотя мы и поменяли данныые только b, но поменялись и данные в с, так как это представление ОДНИХ И ТЕХ же данных
#
# d = b.T  # Транспонирование
# print(d)

# Любое изменение формы меняет лишь представление данных.

# a = np.arange(1, 10)
# b = a  # Создаётся копия, следовательно при изменении а будет менятся b
# a.shape = 3, 3
# print(a, '\n', b)
#
# b = a.view()  # Cоздаётся копия ПРЕДСТАВЛЕНИЯ, что значит при изменении формы а, форма b менятся не будет
# a.shape = 9
# print(a, '\n', b)
#
# a = np.arange(1, 10)
# b = np.array(a)  # Cоздаём копию данных массива а, при этом изменения а не повлекут за собой измения b
# a[0] = 100
# print(a, '\n', b)
# b = a.copy()  # Делает тоже самое



