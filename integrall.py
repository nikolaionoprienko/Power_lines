from os import system  # Для вызова системных команд
import time  # Использую для пауз
import sys  # Для взаимодействия с операционной системой


system("pip install numpy")  # Установка NumPy (Для математических операций)
system("pip install pandas")  # Установка  pandas (Для таблицы)

import numpy as np
import pandas as pd


def out_red(text):
    print("\033[31m{}".format(text))  # красный текст


def out_yellow(text):
    print("\033[33m{}".format(text))  # жёлтый текст


def out_green(text):
    print("\033[32m{}".format(text))  # Зелёный  текст


def f():
    global g
    return eval(g)
    # Делает из введённого пользователем текста формулу, которую может считать программа и подставить
    # которую может считать программа и подставить переменную x.


table = [
    ["Сложение |", "+ |"],
    ["Выяетание |", "- |"],
    ["Умножение |", "* |"],
    ["Деление |", "/ |"],
    ["Модуль |", "abs |"],
    ["a возвести в степени b |", "a**b |"],
    ["Вычисление натурального логарифма от x |", "np.log(x)|"],
    ["Вычисление логарифма х по основанию а |", "np.loga(x)|"],
    ["sin(x) |", "np.sin(x) |"],
    ["cox(x) |", "np.cos(x) |"],
    ["tg(x) |", "np.tan(x) |"],
    ["arc-функции |", "np.arccos(x) и т.д. |"],
]

write = pd.DataFrame(table, columns=["-" * 50, "-" * 50])
print(write, "\n", "-" * 50, " ", "-" * 50, "\n")  # Вывод таблицы и нижнего подчёркивания

a = input("нижний предел интегрирования: ")

check_0 = 0  # Переменная и цикл для проверки правильности введённого значения
while check_0 == 0:
    try:
        a = float(a)
        check_0 = 1
        if np.isnan(a):
            a = input("\n \033[41m\033[1m\033[4m\033[30m Кто-то слишком любопытный :)"
                      " Можно вводить только числа, попробуйте ещё раз:\033[0m ")
            check_0 = 0
    except ValueError:
        a = input("\n \033[41m\033[1m\033[4m\033[30m Можно вводить только числа, попробуйте ещё раз:\033[0m ")

b = input("верхний предел интегрирования (b>a): ")

check_1 = 0  # Переменная и цикл для проверки правильности введённого значения
while check_1 == 0:
    try:
        b = float(b)
        check_1 = 1
        if np.isnan(b):
            b = input("\n \033[41m\033[1m\033[4m\033[30m Кто-то слишком любопытный :)"
                      " Можно вводить только числа, попробуйте ещё раз:\033[0m ")
            check_1 = 0
        elif b <= a:
            b = input("\n \033[41m\033[1m\033[4m\033[30m Пожалуйста, введите так, чтобы было b>a:\033[0m ")
            check_1 = 0
    except ValueError:
        b = input("\n \033[41m\033[1m\033[4m\033[30m Можно вводить только числа, попробуйте ещё раз:\033[0m ")

x = a  # Начальное значение х

g = input('введите функцию (для этого можете использовать, например, функции представленные в таблице) : ')

check = 0  # Переменная и цикл для проверки правильности введённой формулы
while check == 0:
    try:
        f() * 0.01
        check = 1
        time.sleep(1)  # Ожидание поможет избежать наложение уведомления о долгом вычислении на текст программы
    except NameError:
        g = input("\n \033[41m\033[1m\033[4m\033[30m Выражение введено некорректно, попробуйте ещё раз:\033[0m ")
    except SyntaxError:
        g = input("\n \033[41m\033[1m\033[4m\033[30m Выражение введено некорректно, попробуйте ещё раз:\033[0m ")
    except ZeroDivisionError:  # Проверка на деление на ноль
        print("\n \033[41m\033[1m\033[4m\033[30m Деление на ноль! Интеграл скорее всего рассходится. "
              "Программа принудительно завершится через 5 секунд. \033[0m")
        time.sleep(5)
        sys.exit()  # Принудительное завершение программы
    except AttributeError:
        g = input("\n \033[41m\033[1m\033[4m\033[30m Выражение введено некорректно, попробуйте ещё раз:\033[0m ")

dx = input(
    "прирощение х (чем меньше,тем точнее, но дольше вычисления!!! "
    "\nВероятно лучше использовать числа от 0.1 до 0.0001 т.е. ещё и dx > 0):  ")


check_2 = 0  # Переменная и цикл для проверки правильности введённого значения
while check_2 == 0:
    try:
        dx = float(dx)
        check_2 = 1
        if np.isnan(dx):
            dx = input("\n \033[41m\033[1m\033[4m\033[30m Кто-то слишком любопытный :)"
                       " Можно вводить только числа, попробуйте ещё раз:\033[0m ")
            check_2 = 0
        elif (dx < 0) or (dx > ((b-a)/100)):
            dx = input("\n \033[41m\033[1m\033[4m\033[30m Либо dx отрицательное, либо слишком большой."
                       " Попробуйте ещё раз ввести dx ^_^  :\033[0m ")
            check_2 = 0
    except ValueError:
        dx = input("\n \033[41m\033[1m\033[4m\033[30m Можно вводить только числа, попробуйте ещё раз:\033[0m ")

quantity = (b - a) / dx  # Количество вычислений


def iteration(n):
    return int((100 * n) // quantity)  # Процент совершённых итераций


rounding = len(str(dx).split(".")[1])  # Подсчёт количества цифр после запятой в dx (для округления результата)

summ = 0  # Собственно определённый интеграл
i = 0  # Номер итерации

while x <= b:
    i = i + 1
    if np.isnan(f()):  # Проверка на неопределённости (например 0/0)
        print("\n \033[42m\033[1m\033[4m\033[30m Вероятно пропущена неопределённость. \033[0m")
    else:
        try:
            summ += f() * dx  # Площадь маленького прямоугольника из которых будет состоять общая площадь
        except ZeroDivisionError:  # Проверка на деление на ноль
            print("\n \033[41m\033[1m\033[4m\033[30m Деление на ноль! Интеграл скорее всего рассходится. "
                  "Программа принудительно завершится через 5 секунд. \033[0m")
            time.sleep(5)
            sys.exit()  # Принудительное завершение программы
    x += dx  # Переход к следующему значению х
    if (i <= quantity / 3) \
            and iteration(i) != iteration(i - 1):  # Линия прогресса вычисления (меньше трети вычислений -- красная)
        out_red("")
        print("|", "-" * iteration(i), " " * int((100 - iteration(i))), "|",
              iteration(i), "/ 100")

    elif (i <= 2 * quantity / 3) \
            and (i > quantity / 3) \
            and iteration(i) != iteration(
        i - 1):  # Линия прогресса вычисления (меньше двух третих вычислений -- жёлтый)
        out_yellow("")
        print("|", "-" * iteration(i), " " * int((100 - iteration(i))), "|",
              iteration(i), "/ 100")

    elif i >= 2 * quantity / 3 \
            and iteration(i) != iteration(i - 1):  # Линия прогресса вычисления (больше двух третей -- зелёный)
        out_green("")
        print("|", "-" * iteration(i), " " * int((100 - iteration(i))), "|",
              iteration(i), "/ 100")

# Знаю, что есть прекрасные библиотеки для добавления прогресс бара, но хотелось сделать свой :)

print("\033[36m\033[1m{}".format("\n"))  # Бирюзовый цвет
print("∫", g, "dx = ", round(summ, rounding - 1))  # Вывод результата с округлением
print("x ∈ [", a, ", ", b, "]")  # Область интегрирования

out_red("\n")
out_red("Программа завершится через 20 с.")
time.sleep(20)
# Автоматическое завершение программы (чтобы при вкючении документа непосредственно, консоль не закрывалась сразу)
